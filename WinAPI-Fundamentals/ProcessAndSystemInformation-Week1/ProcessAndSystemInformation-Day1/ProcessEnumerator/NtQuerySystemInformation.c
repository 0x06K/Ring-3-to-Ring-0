/*
 * NtQuerySystemInformation
 *
 * Retrieves various types of system-wide information from the Windows kernel.
 * This is an undocumented / semi-documented native API exposed by ntdll.dll.
 *
 * Commonly used for:
 *  - Enumerating running processes (SystemProcessInformation)
 *  - Querying system performance, CPU, memory, and kernel state
 *  - Retrieving security, policy, and hardware mitigation data
 *
 * Parameters:
 *  - SystemInformationClass:
 *      Specifies the type of information to retrieve
 *      (e.g., SystemProcessInformation, SystemBasicInformation, etc.)
 *
 *  - SystemInformation:
 *      Pointer to a caller-allocated buffer that receives the requested data.
 *
 *  - SystemInformationLength:
 *      Size of the buffer in bytes.
 *
 *  - ReturnLength (optional):
 *      Receives the required buffer size if the supplied buffer is too small.
 *
 * Common Enumeration Usage:
 *  - SystemProcessInformation:
 *      Returns a linked list of SYSTEM_PROCESS_INFORMATION structures,
 *      each describing a running process and its threads.
 *
 * Notes:
 *  - Not officially documented or guaranteed stable across Windows versions.
 *  - Must be dynamically resolved via GetProcAddress from ntdll.dll.
 *  - Preferred over Toolhelp APIs for stealth, performance, or kernel-level visibility.
 *
 * Typical Use Case:
 *  - Low-level process enumeration
 *  - Malware analysis / EDR development
 *  - Advanced system diagnostics
 *
 * Return Value:
 *  - STATUS_SUCCESS on success
 *  - NTSTATUS error code on failure
 */

#include <windows.h>     // For basic Windows types like HANDLE, ULONG, etc.
#include <winternl.h>    // For NTSTATUS, SYSTEM_INFORMATION_CLASS, UNICODE_STRING
#include <stdio.h>       // For printf (if printing)
#include "colors.h"


#ifndef STATUS_INFO_LENGTH_MISMATCH
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004)
#endif

/*
 * _SYSTEM_PROCESS_INFORMATION
 *
 * Structure returned by NtQuerySystemInformation with SystemProcessInformation.
 * Contains information about a single process and is part of a linked array.
 *
 * Fields:
 *  - NextEntryOffset: Offset to the next entry in bytes. 0 if last process.
 *  - NumberOfThreads: Number of threads in this process.
 *  - Reserved[3]: Internal kernel data, do not use.
 *  - CreateTime: Process creation time (LARGE_INTEGER, 100-ns intervals since Jan 1, 1601).
 *  - UserTime: CPU time spent in user mode.
 *  - KernelTime: CPU time spent in kernel mode.
 *  - ImageName: UNICODE_STRING with the executable name (may be NULL for system processes).
 *  - BasePriority: Base scheduling priority of the process.
 *  - UniqueProcessId: Process ID (PID).
 *  - InheritedFromProcessId: Parent process PID.
 *  - HandleCount: Number of handles currently opened by the process.
 *  - SessionId: Windows session ID.
 *  - PageDirectoryBase: Internal kernel pointer, ignore in user-mode.
 *  - PeakVirtualSize: Maximum virtual memory used.
 *  - VirtualSize: Current virtual memory used.
 *  - PageFaultCount: Number of page faults generated by the process.
 *  - PeakWorkingSetSize: Maximum working set (physical memory) used.
 *  - WorkingSetSize: Current working set size.
 *  - QuotaPeakPagedPoolUsage: Peak paged pool usage by process.
 *  - QuotaPagedPoolUsage: Current paged pool usage.
 *  - QuotaPeakNonPagedPoolUsage: Peak non-paged pool usage.
 *  - QuotaNonPagedPoolUsage: Current non-paged pool usage.
 *  - PagefileUsage: Bytes of pagefile used.
 *  - PeakPagefileUsage: Maximum pagefile usage.
 *  - PrivatePageCount: Memory pages allocated only for this process.
 *  - ReadOperationCount: Number of read I/O operations.
 *  - WriteOperationCount: Number of write I/O operations.
 *  - OtherOperationCount: Number of other I/O operations.
 *  - ReadTransferCount: Bytes read by the process.
 *  - WriteTransferCount: Bytes written by the process.
 *  - OtherTransferCount: Bytes transferred in other I/O operations.
 *
 * Notes:
 *  - For process enumeration, you mostly care about UniqueProcessId, InheritedFromProcessId, 
 *    ImageName, and NumberOfThreads.
 *  - Most memory and I/O fields are optional for basic enumeration; useful for profiling.
 *  - Reserved and kernel-internal fields should be ignored in user-mode applications.
 */

typedef NTSTATUS(WINAPI* _NtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);


int main() {
    HMODULE ntdll = GetModuleHandleA("ntdll.dll");
    if (!ntdll) return -1;

    _NtQuerySystemInformation NtQuerySystemInformation =
        (_NtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
    if (!NtQuerySystemInformation) return -1;
    

    ULONG bufferSize = 0x10000; // start with 64KB
    PVOID buffer = NULL;
    NTSTATUS status;
    ULONG returnLength;

    do {
        buffer = malloc(bufferSize);
        if (!buffer) return -1;

        status = NtQuerySystemInformation(SystemProcessInformation, buffer, bufferSize, &returnLength);
        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            free(buffer);
            bufferSize *= 2; // double buffer size
        } else if (!NT_SUCCESS(status)) {
            free(buffer);
            return -1;
        }
    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    PSYSTEM_PROCESS_INFORMATION spi = (PSYSTEM_PROCESS_INFORMATION)buffer;

    while (1) {
        // Print PID and process name
        wprintf(L"PID: %u, Name: %wZ\n",
                (DWORD)(ULONG_PTR)spi->UniqueProcessId,
                &spi->ImageName);

        if (spi->NextEntryOffset == 0)
            break;

        spi = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)spi + spi->NextEntryOffset);
    }

    free(buffer);
    return 0;
}
